/**********************************************************************
* Filename    : BlockClassifierFSM.ino
* Description : Lab 2 - FSM Image Capture + TFLite Classification + Logging
* Author      : Next Shift / DSAI Camp
* Modified    : 2025-05-31


**********************************************************************/

#include <Arduino.h>
#include "esp_camera.h"
#include <WiFi.h>
#include "config.h"
#include "model_data.h" // from converted .tflite model
#include "TensorFlowLite.h"
#include "tensorflow/lite/micro/kernels/micro_ops.h"
#include "tensorflow/lite/micro/micro_error_reporter.h"
#include "tensorflow/lite/micro/micro_interpreter.h"
#include "tensorflow/lite/schema/schema_generated.h"
#include "tensorflow/lite/version.h"

// === TFLite Setup ===
tflite::MicroErrorReporter tflErrorReporter;
const tflite::Model* tflModel = nullptr;
tflite::MicroInterpreter* interpreter = nullptr;
constexpr int tensor_arena_size = 20 * 1024;
uint8_t tensor_arena[tensor_arena_size];

// === Classification Output ===
String label = "unknown";
float confidence = 0.0;
bool usedFallback = false;

String labels[] = {"red_tall", "blue_short", "green_round", "yellow_square", "purple_triangle"};
const int num_classes = sizeof(labels) / sizeof(labels[0]);

// === FSM State Definitions ===
typedef void (*StateHandler)();
typedef void (*LifecycleHook)();

struct StateConfig {
  const char* name;
  StateHandler handler;
  unsigned long duration;
  const char* next;
  LifecycleHook onEnter;
  LifecycleHook onExit;
};

int currentStateIndex = 0;
unsigned long stateStartTime = 0;

// === Camera Config ===
void setupCamera() {
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = 5;
  config.pin_d1 = 18;
  config.pin_d2 = 19;
  config.pin_d3 = 21;
  config.pin_d4 = 36;
  config.pin_d5 = 39;
  config.pin_d6 = 34;
  config.pin_d7 = 35;
  config.pin_xclk = 0;
  config.pin_pclk = 22;
  config.pin_vsync = 25;
  config.pin_href = 23;
  config.pin_sscb_sda = 26;
  config.pin_sscb_scl = 27;
  config.pin_pwdn = 32;
  config.pin_reset = -1;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_RGB565;

  if(psramFound()) {
    config.frame_size = FRAMESIZE_QVGA;
    config.jpeg_quality = 10;
    config.fb_count = 2;
  } else {
    config.frame_size = FRAMESIZE_QQVGA;
    config.jpeg_quality = 12;
    config.fb_count = 1;
  }

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed: 0x%x\n", err);
  } else {
    Serial.println("[CAMERA] Ready");
  }
}

// === FSM State Handlers ===
void captureState() {
  camera_fb_t *fb = esp_camera_fb_get();
  if (!fb) {
    Serial.println("[ERROR] Camera capture failed");
    return;
  }

  // HINT: Replace with preprocessing for model input if needed
  Serial.printf("[CAPTURE] Frame size: %d bytes\n", fb->len);
  esp_camera_fb_return(fb);
}

void classifyState() {
  usedFallback = false;

  if (interpreter != nullptr) {
    float* scores = interpreter->typed_output_tensor<float>(0);
    int predictedIndex = 0;
    float maxProb = scores[0];

    for (int i = 1; i < num_classes; i++) {
      if (scores[i] > maxProb) {
        maxProb = scores[i];
        predictedIndex = i;
      }
    }

    label = labels[predictedIndex];
    confidence = maxProb;
    Serial.printf("[CLASSIFY] %s (%.2f)\n", label.c_str(), confidence);
  } else {
    usedFallback = true;
    int predictedIndex = random(0, num_classes);
    label = labels[predictedIndex];
    confidence = random(70, 100) / 100.0;
    Serial.printf("[FALLBACK] %s (%.2f)\n", label.c_str(), confidence);
  }
}

void transmitState() {
  unsigned long timestamp = millis();
  String model_used = usedFallback ? "default" : config.model;

  String result = "{\"label\": \"" + label + "\"," +
                  " \"confidence\": " + String(confidence, 2) + "," +
                  " \"timestamp\": " + String(timestamp) + "," +
                  " \"source\": \"" + config.source + "\"," +
                  " \"sensor\": \"" + config.sensor + "\"," +
                  " \"model\": \"" + model_used + "\" }";

  Serial.println(result);
}

void waitState() {
  // Optional pause or LED blink
}

// === FSM Lifecycle Hooks ===
void enterCapture()   { Serial.println("[FSM] Capture image..."); }
void enterClassify()  { Serial.println("[FSM] Classify object..."); }
void enterTransmit()  { Serial.println("[FSM] Transmit result..."); }

// === FSM Configuration ===
StateConfig states[] = {
  { "CAPTURE",   captureState,   1000, "CLASSIFY", enterCapture, nullptr },
  { "CLASSIFY",  classifyState,  1000, "TRANSMIT", enterClassify, nullptr },
  { "TRANSMIT",  transmitState,  1000, "WAIT",     enterTransmit, nullptr },
  { "WAIT",      waitState,      2000, "CAPTURE",  nullptr, nullptr }
};
const int NUM_STATES = sizeof(states) / sizeof(StateConfig);

// === Setup & Loop ===
void setup() {
  Serial.begin(115200);
  delay(500);
  setupCamera();

  tflModel = tflite::GetModel(model_tflite);
  if (tflModel->version() != TFLITE_SCHEMA_VERSION) {
    Serial.println("[TFLITE] Model schema version mismatch");
    return;
  }

  static tflite::MicroMutableOpResolver<5> resolver;
  resolver.AddSoftmax();
  resolver.AddFullyConnected();
  resolver.AddReshape();
  resolver.AddConv2D();
  resolver.AddAveragePool2D();

  interpreter = new tflite::MicroInterpreter(tflModel, resolver, tensor_arena, tensor_arena_size, &tflErrorReporter);
  interpreter->AllocateTensors();

  Serial.print("[FSM] Starting in state: ");
  Serial.println(states[currentStateIndex].name);
  stateStartTime = millis();
  if (states[currentStateIndex].onEnter) states[currentStateIndex].onEnter();
}

void loop() {
  unsigned long now = millis();
  StateConfig current = states[currentStateIndex];
  current.handler();

  if (current.duration > 0 && now - stateStartTime >= current.duration) {
    if (current.onExit) current.onExit();

    for (int i = 0; i < NUM_STATES; i++) {
      if (strcmp(states[i].name, current.next) == 0) {
        currentStateIndex = i;
        break;
      }
    }

    stateStartTime = millis();
    if (states[currentStateIndex].onEnter) states[currentStateIndex].onEnter();
  }
}
